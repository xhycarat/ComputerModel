# ComputerModel
2024.3计算机大作业<br>
## 基本要求
（1）展示二进制（数据和代码）的原理，演示整数（补码）、浮点数的原理、指令集设计原理；<br>
（2）展示以内存为中心的程序员视角的计算机模型，演示计算机加电开机的过程模型，演示计算机内存编指和分段（Segment），演示处理器计算和I/O的过程；<br>
（3）展示基于“JUMP”的代码执行“顺序、分支、循环”的三个基本流程；<br>
（4）展示从高级语言到二进制代码的编译过程，演示具有运行时环境（如JRE）的代码运行过程；<br>
## 加分项
（1）参考MIPS或者RISC-V指令集规范，完整演示指令集和二进制的对应关系；<br>
（2）参考Java ByteCode、.Net IL等中间代码规范，完整演示中间代码的编译和运行过程；<br>
（3）参考X86计算机开机的地址规范，演示开机过程；<br>
（4）可以使用JQuery、Bootstrap、VUE等成熟的前端框架。<br>
## 目标及完成情况
<table border="1">
  <tr>
    <th>目标</th>
    <th>完成情况</th>
  </tr>
  <tr>
    <td>主页面</td>
    <td>图文并茂，采用侧边栏、顶栏、底栏、主要区域的页面布局，添加搜索功能</td>
  </tr>
  <tr>
    <td>展示二进制（数据和代码）的原理，演示整数（补码）、浮点数的原理、指令集设计原理</td>
    <td>√</td>
  </tr>
  <tr>
    <td>展示以内存为中心的程序员视角的计算机模型</td>
    <td>√</td>
  </tr>
  <tr>
    <td>演示计算机加电开机的过程模型（动画）</td>
    <td>√</td>
  </tr><tr>
    <td>演示计算机内存编指和分段（Segment）</td>
    <td>√</td>
  </tr><tr>
    <td>演示处理器计算和I/O的过程（动画）</td>
    <td>√</td>
  </tr><tr>
    <td>展示基于“JUMP”的代码执行“顺序、分支、循环”的三个基本流程</td>
    <td>√</td>
  </tr><tr>
    <td>展示从高级语言到二进制代码的编译过程</td>
    <td>√</td>
  </tr><tr>
    <td>演示具有运行时环境（如JRE）的代码运行过程（动态）</td>
    <td>√</td>
  </tr>
  <table border="1">
    <tr>
      <th>拓展</th>
      <th>完成情况</th>
    </tr>
    <tr>
      <td>参考MIPS或者RISC-V指令集规范，完整演示指令集和二进制的对应关系</td>
      <td></td>
    </tr>
    <tr>
      <td>参考Java ByteCode、.Net IL等中间代码规范，完整演示中间代码的编译和运行过程</td>
      <td></td>
    </tr>
    <tr>
      <td>参考X86计算机开机的地址规范，演示开机过程</td>
      <td>√</td>
    </tr>
    <tr>
      <td>VUE</td>
      <td>√</td>
    </tr>
  </table>

## 项目简介
本项目是一个基于 Vue.js 实现的教育工具，旨在通过互动式可视化展示来解释计算机科学中的核心概念，包括二进制原理、指令集设计原理、计算机模型展示以及代码执行流程。通过本项目，用户可以更直观地理解计算机的工作原理及其执行过程。

## 主要功能与实现技术
### vue框架
#### 数据绑定和响应式数据

- **双向数据绑定**：
  - 使用`v-model`进行双向数据绑定，允许实时更新数据与视图。
- **插值表达式**：
  - 使用`{{}}`插值表达式在模板中显示变量值。

#### 条件渲染

- 使用`v-if`、`v-else-if`、`v-else`来根据条件渲染不同的HTML结构。

#### 列表渲染

- 使用`v-for`在模板中遍历数组或对象，生成重复的DOM元素。

#### 事件处理

- 使用`@event=""`或`v-on:event=""`监听DOM事件并调用Vue实例中的方法。

#### 组件动态切换

- 通过改变数据来动态改变渲染的组件或内容，如通过改变`currentView`变量的值来切换不同视图的显示。

#### 计算属性和侦听器（Watchers）

- 通过`watch`对象监听数据变化并执行相应操作。

#### 样式绑定

- 使用`v-bind:style`或`:style`以及`v-bind:class`或`:class`动态绑定HTML元素的样式和类，根据数据的变化调整样式。

#### Vue实例的方法

- 在Vue实例的`methods`对象中定义方法，这些方法可以通过事件绑定或其他方式被调用。

#### Vue指令

- 使用Vue指令（如`v-model`、`v-for`、`v-if`、`v-on`等）来扩展HTML元素的功能。
### 主页面与搜索功能

主页面提供了一个概览视图，用户可以通过顶部的导航栏快速访问不同的教育模块。每个模块针对一个特定的计算机科学概念提供详细的信息和交互式演示。

此外，主页面还集成了一个搜索功能，用户可以通过输入关键词快速找到相关的教学内容。这一功能便于用户在众多教学模块中迅速定位到他们感兴趣的部分。

### 二进制原理展示

#### 整数、浮点数与二进制的转换
- **技术栈**：Vue.js
- **功能描述**：实现了用户输入十进制整数或浮点数后，展示其转换成二进制形式的过程及结果。对于整数，还额外展示原码和补码；对于浮点数，展示符号位、指数位和尾数位，对应的阶数和实际的阶码值，以及按照 IEEE 754 标准的转换结果。
- **实现方法**：使用 Vue 的双向数据绑定和条件渲染特性，动态展示转换过程和结果。通过计算属性和方法，处理用户输入并计算相应的二进制表示。
- **项目日志**：对于整数的二进制，我是通过分支条件分成了正数负数，分别确定其符号位（由于负数的反码是符号位保持不变，其余位取反，所以给负数也是0），对于正数，补码就是原码的二进制（加上符号位），对于负数，我先把二进制拆成数组，遍历每一位（0 1互换），然后就得到了反码，再将其转化为十进制+1得到补码的十进制，转化为二进制再在前面补全位数即可；对于浮点数，通过写一个函数方法toFloat（）来让计算机实现了大致的计算，我这里采用的是以单精度浮点数为例，数符分配是1位，阶码分配了8位，尾数分配了是23位，整数部分用除2取余的方法，小数部分用乘2取整的方法
转换成二进制的浮点数，即把小数点移动到整数位只有1，移动几位，阶数就是几的二进制，也就是说，我只需要把整数和小数分开，把整数位-1即可得到阶数，而阶码=阶数+偏移量（127）
小数部分，我这里用了一个while循环，乘2取整法迭代计算小数部分
然后我发现这里可能会出现小数部分计算完还有剩余的情况，所以就写了toCarry（）方法来处理可能的进位问题
先把carry初始为1，然后将二进制拆成数组，并反转，方便从最低位开始进位，然后用一个循环遍历数组，如果当前值+carry=2，则进位，否则结束循环并清除carry
如果到最后carry仍为1，则在数组最后（二进制最高位）加上1



### 指令集设计原理

#### 设计指令集的原则和重要方面
- **技术栈**：Vue.js
- **功能描述**：介绍计算机指令系统设计的基本概念和原理，包括操作数类型、存储方式及指令设计风格等。
- **实现方法**：通过组件化开发，每个概念或原理为一个独立的组件，通过 Vue 的路由管理，实现概念之间的切换和浏览。
- **项目日志**：-对于展示指令集设计原理，我一开始先去搜索了指令集架构进行学习，然后制作了一个交互式的工具，可以通过点击按钮来一步一步了解CISC/RISC，这里是通过instructionstep的值（0 1 2）来判断调用哪个方法，显示哪一个步骤
-然后我针对指令集设计里面的偏移寻址方法中的相对寻址做了个简单的模拟，可以输入当前的内存地址和偏移量，然后用侦听，任意一个一旦发生变化，js调用calculateFinalAddress方法，将两者相加得到最终地址，然后创建模拟内存地址的表格的数组，找到相应的数组进行显示红色
-对于剩下的指令集设计原理，我自己制作了思维导图，用图片形式插入展示


### 计算机模型展示

#### x86计算机加电开机过程模型
- **技术栈**：Vue.js
- **功能描述**：通过图文并茂的方式并且运用简单的动画展示计算机启动流程的各个步骤和相关概念。
- **实现方法**：利用 Vue 的组件和路由功能，创建一个多步骤的交互式界面，每一步使用不同的组件来展示相关的信息和图像。
- **项目日志**：对于计算机加电开机的过程，我是制作了其主要步骤的简单动画来进行演示，我用黑色框来代表一个计算机模型，我用了setTimeout来控制延时显示，使得展示更为充分，在加电自检部分中，我对文本添加了闪烁效果模拟检测过程和错误发现，第二部分未找到设备在5秒后会自动变成找到启动设备SSD，模拟了BIOS（基本输入输出系统）或UEFI（统一可扩展固件接口）寻找包含启动信息的存储设备的过程，并用鼠标悬停监听@mouseover @mouseout控制显示关于x86地址规范的内容，在启动加载器阶段，我将读取引导分区的背景色设置为0%50%100%三个颜色动态渐变，模拟正在读取这一状态，下方进度条设置的为循环拖动，在操作系统加载部分，我将系统初始化中设置为内核加载进度条首次加满后显示，来模拟先后，在用户登录界面我设置的点击登录按钮5秒后显示欢迎界面，模拟环境准备所需要的时间

#### 计算机内存编址和分段
- **技术栈**：Vue.js
- **功能描述**：展示了计算机内存的分段和编址方式，包括代码段、数据段和堆栈段等，以及如何通过内存操作演示进行数据的读写。
- **项目日志**：在计算机内存编指和分段中，我先是用了Vue框架的事件监听器，在鼠标移动到对应分段的时候，显示基址和内存大小，鼠标移开时隐藏，具体是通过showTooltip方法，将传入的内存段的内存和大小赋值给相应属性，并且令tooltip对象的visible属性为true，通过hideTooltip方法，将visible设置为false，在HTML中和css控制其显示隐藏
接下来是一个用户可以输入16进制地址获取其所在代码段，首先调用highlightSegment方法，将16进制转化为十进制，然后遍历所有的内存段求其结束地址（基址+转化为字节的大小）然后找到地址所在内存段，高亮显示
为了将大小转化为字节，我创建了convertSizeToBytes方法，使用正则表达式匹配字符串中的字母部分 获得存储单位（KB MB）并将其数值赋给value，然后用switch语句分别计算两种情况
接下来我模拟了内存的写入和读取，用户输入地址和数据，用v-model将数据同步到addressInput和dataInput变量里，然后我在js里面创建了writeData方法，用Vue的$set方法 ，将输入的数据写入memory对象，确保Vue能够追踪到memory对象属性的变化，同时创建readData方法，用户输入地址（若不输入则弹窗），从memory里面读取相应的数据 <br>用户可以选择简单的指令，然后显示寄存器和ALU状态变化，为此我创建了executeInstruction方法，通过分支结构判断指令是否含有函数（在data中），如果是就更新ALU状态，在这个的下面我制作了处理器工作流程的演示，和前面的鼠标悬停一样用了监听，用showDetails和clearDetails方法来显示和清除详细信息（detail）


#### 处理器计算和I/O
- **技术栈**：Vue.js
- **功能描述**：提供了一个虚拟处理器模拟器，允许用户选择执行不同的指令，并展示寄存器和ALU（算术逻辑单元）的状态变化。介绍了I/O请求发起、调度、执行、中断和直接内存访问（DMA）等概念。
- **项目日志**：点击按钮后滑块移动模拟了用户与计算机之间交互的开始，2秒后自动消失，模拟了I/O操作的发起和数据的临时性质（创建一个div并添加到DOM里表示数据块）
在多个I/O请求之间决定优先级，哪些请求先执行，哪些后执行（通过遍历并显示每个请求元素，并为它们设置CSS动画和延迟）
通过一个示意图来说明数据是如何在设备、CPU和内存之间移动的
中断是指外部设备或其他硬件向CPU发出的信号，告知CPU暂停当前任务，处理更紧急的任务。直接内存访问（DMA）则是一种技术，允许外部设备直接和内存交换数据，而不需要CPU介入，这样可以提高数据传输的效率
通过弹出一个警告框来告知用户“I/O操作完成！”，模拟了在I/O操作完成后系统给予用户的反馈





### 代码执行流程展示

#### 基于“JUMP”的代码执行流程
- **技术栈**：Vue.js
- **功能描述**：通过可视化的方式应用演示了代码执行的基本流程，包括代码输入、执行和寄存器状态的更新。
- **实现方法**：允许用户输入RISC-v规范下的指令，然后展示对应的执行流程（寄存器状态）。
- **项目日志**：对于基于JUMP的代码执行顺序分支循环，我采用的是RISC-v规范，将用户输入的内容，遍历每一行找到标签label所对应的行号（以：结尾）遍历检查，跳过格式不正确的行，然后分解每一行代码，获得指令名，目标寄存器，源寄存器或者立即数值，运用switch对不同指令执行相应操作，使用扩展运算符“…”赋值给this.registers实现更新


### 高级语言到二进制代码的编译过程展示
- **技术栈**：Vue.js
- **功能描述**：展示了从源代码到机器码的整个编译过程，包括词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成和链接等步骤,通过模拟Java代码的执行，介绍了类加载、链接、执行阶段、JVM操作和程序退出等概念，提供了一个直观的运行时环境演示。
- **项目日志**：我先是做了一个静态展示，仍然是利用了鼠标悬停监听，通过showStep方法和hideStep方法使得currentStep为不同的步骤
接下来是一个相对动态显示，当点击运行代码后，先逐字显示源代码，模拟源代码的读取，然后箭头指向虚拟机，模拟虚拟机过程，其中逐字显示Java字节码，模拟Java编译器，然后箭头指向classload，模拟类加载器将.class文件加载到运行时环境中，这段代码是没有静态变量的，所以此处的链接中为静态字段分配存储空间仅做展示……
整个过程运用了延时效果（在simulateRun方法中使用setTimeout）并使右侧滚动条始终置于底部


## 总结
本项目通过将抽象的计算机科学概念具体化、可视化，使得用户能够通过直观的交互和动态展示来深入理解计算机的工作原理。项目采用 Vue.js 框架开发，利用其组件化和响应式特性，高效地实现了各功能模块。
## 参考网址
框架Vue：https://vuejs.org/guide/introduction.html
源码 反码 补码 ：http://t.csdnimg.cn/y7BxG
指令集设计原理：http://t.csdnimg.cn/tfRdU 
汇编jump ：http://t.csdnimg.cn/PnfoQ
X86 系统开机流程：http://t.csdnimg.cn/C3fZi 
RISC-V规范：https://riscv.org/china/ 
https://th0ar.gitbooks.io/xv6-chinese/content/

## 鸣谢
-间接参考**孙更欣**直接参考**毛洋洋**的在线编译器，学习了对Compiler Explorer 的 API调用方法，后附学习笔记，时间原因并未在项目中完全展示。
-参考**侯博涵**学长给出的设计建议。
-参考**郭舒丹**给出的关于Vue框架安装学习的建议，特别感谢**郭舒丹**在项目完成过程中提供的精神支持。
-参考**毛洋洋**的项目文档格式
-参考**贾永芹**女士和**刘淼**先生对于API调用方法的理解，特别感谢**贾永芹**女士有关web的指导
-参考ChatGPT对于动画展示的相关思路
## 附对Compiler Explorer 的 API调用方法的学习笔记
## 第一个方法：onlanguagechange()

```javascript
onlanguagechange() {
    this.compilerselect = true;
    this.selectloader = true;
    axios.get("https://godbolt.org/api/compilers/"+this.form.lang).then(response => {
        this.compilers = response.data;
        this.compilerselect = false;
        this.selectloader = false;
        this.form.compile='';
    }).catch(err => {
        console.log(err);
        this.selectloader = false;
    });
}
```

- **请求地址**："https://godbolt.org/api/languages"（地址后面加的是选择的语言）；
- **接口方法**：使用axios的get方法进行请求，表明这是一个GET类型的API调用。这个取决于API定义的接口规范，开发的时候也可以使用POST，安全性高且支持各类请求方法。
- **请求参数**：参数通过URL传递，这里是`this.form.lang`，表示用户选择的编程语言。因为是get方法所以参数是以form的形式跟在接口地址后面。
- **返回值处理**：接口返回的数据通过`response.data`获取，然后赋值给组件的`compilers`属性。
- **异常处理**：通过`.catch(err => console.log(err))`打印接口调用异常结果。

## 第二个方法：onCompiler()

```javascript
onCompiler() {
    if (this.form.compiler == "") {
        alert("请选择编译器");
        return;
    }
    if (this.form.source == "") {
        alert("请输入源代码");
        return;
    }
    if (this.form.lang == "") {
        alert("请选择语言");
        return;
    }
    this.result = "正在编译........";
    this.resultloader = true;
    axios.post("https://godbolt.org/api/compiler/" + this.form.compiler + "/compile", this.form).then(response => {
        console.log("success");
        this.Data = response.data.asm;
        this.result = "";
        for (let i = 0; i < this.Data.length; i++) {
            this.result += this.Data[i].text + '\n';
        }
        this.resultloader = false;
    }).catch(err => {
        console.log(err);
        this.resultloader = false;
    });
}
```

- **请求地址**："https://godbolt.org/api/compiler/"+this.form.compiler+"/compile"；这里用了+this.form.compiler+，是因为请求地址根据语言类型可能有多种分支，所以巧妙的动态去调用前台页面所选择的语言去调用不同接口。
- **接口方法**：使用axios的post方法进行请求，表明这是一个POST类型的API调用。
- **请求参数**：this.form   --因为是post方法所以通常会将表单数据作为请求体（request body）发送到服务器，作为post方法的第二参数。
- **返回值处理**：this.Data = response.data.asm;   --这里不是直接用的response.data接口返回的所有值，因为明确知道返回的都是什么，所以只取了返回结构体中.asm。
- **异常处理**：通过`.catch(err => console.log(err))`捕获并打印错误信息。
- **其他**：this.result="";
                for(let i=0;i<this.Data.length;i++){
                    this.result+=this.Data[i].text+'\n';
                }   --为了显示”正在编译“，看起来好像正在执行数据传输，实际上返回值已经到了
